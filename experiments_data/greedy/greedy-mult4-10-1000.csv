Area,Delay,Score,Current Run,Episode,Verilog
N/A,N/A,-1,0,0,"//Please finish designing the 4 bit multiplier module (multiplier_4) below.
//There are two 4 bit inputs (A and B) and an 8 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_4(output [7:0] product, input [3:0] A, B);
	wire [3:0] A_B;
	wire [7:0] product_temp;
	
	assign A_B = A * B;
	
	multiplier_2 m1(product_temp, A_B[1:0], A_B[3:2]);
	multiplier_2 m2(product, A_B[3:2], A_B[7:4]);
	
	assign product = product_temp;
	
endmodule

module multiplier_2(output [7:0] product, input [1:0] A, B);
	wire [1:0] A_B;
	wire [7:0] product_temp;
	
	assign A_B = A * B;
	
	multiplier_1 m1(product_temp, A_B[1:0]);
	multiplier_1 m2(product, A_B[1:0]);
	
	assign product = product_temp;
	
endmodule

module multiplier_1(output [7:0] product, input A);
	wire [7:0] A_temp;
	
	assign A_temp = A << 1;
	
	multiplier_4 m1(product, A_temp[3:0], A_temp[7:4]);
	
endmodule"
N/A,N/A,-1,1,0,"//Please finish designing the 4 bit multiplier module (multiplier_4) below.
//There are two 4 bit inputs (A and B) and an 8 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_4(output [7:0] product, input [3:0] A, B);
	wire [3:0] A_B;
	wire [7:0] product_temp;
	
	assign A_B = A * B;
	
	multiplier_2 m1(product_temp, A_B[1:0], A_B[3:2]);
	multiplier_2 m2(product, A_B[3:2], A_B[7:4]);
	
	assign product = product_temp;
	
endmodule

module multiplier_2(output [7:0] product, input [1:0] A, B);
	wire [1:0] A_B;
	wire [7:0] product_temp;
	
	assign A_B = A * B;
	
	multiplier_1 m1(product_temp, A_B[1:0]);
	multiplier_1 m2(product, A_B[1:0]);
	
	assign product = product_temp;
	
endmodule

module multiplier_1(output [7:0] product, input A);
	wire [7:0] A_temp;
	
	assign A_temp = A << 1;
	
	multiplier_4 m1(product, A_temp[3:0], A_temp[7:4]);
	
endmodule"
N/A,N/A,-1,2,0,"//Please finish designing the 4 bit multiplier module (multiplier_4) below.
//There are two 4 bit inputs (A and B) and an 8 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_4(output [7:0] product, input [3:0] A, B);
	wire [3:0] A_B;
	wire [7:0] product_temp;
	
	assign A_B = A * B;
	
	multiplier_2 m1(product_temp, A_B[1:0], A_B[3:2]);
	multiplier_2 m2(product, A_B[3:2], A_B[7:4]);
	
	assign product = product_temp;
	
endmodule

module multiplier_2(output [7:0] product, input [1:0] A, B);
	wire [1:0] A_B;
	wire [7:0] product_temp;
	
	assign A_B = A * B;
	
	multiplier_1 m1(product_temp, A_B[1:0]);
	multiplier_1 m2(product, A_B[1:0]);
	
	assign product = product_temp;
	
endmodule

module multiplier_1(output [7:0] product, input A);
	wire [7:0] A_temp;
	
	assign A_temp = A << 1;
	
	multiplier_4 m1(product, A_temp[3:0], A_temp[7:4]);
	
endmodule"
N/A,N/A,-1,3,0,"//Please finish designing the 4 bit multiplier module (multiplier_4) below.
//There are two 4 bit inputs (A and B) and an 8 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_4(output [7:0] product, input [3:0] A, B);
	wire [3:0] A_B;
	wire [7:0] product_temp;
	
	assign A_B = A * B;
	
	multiplier_2 m1(product_temp, A_B[1:0], A_B[3:2]);
	multiplier_2 m2(product, A_B[3:2], A_B[7:4]);
	
	assign product = product_temp;
	
endmodule

module multiplier_2(output [7:0] product, input [1:0] A, B);
	wire [1:0] A_B;
	wire [7:0] product_temp;
	
	assign A_B = A * B;
	
	multiplier_1 m1(product_temp, A_B[1:0]);
	multiplier_1 m2(product, A_B[1:0]);
	
	assign product = product_temp;
	
endmodule

module multiplier_1(output [7:0] product, input A);
	wire [7:0] A_temp;
	
	assign A_temp = A << 1;
	
	multiplier_4 m1(product, A_temp[3:0], A_temp[7:4]);
	
endmodule"
